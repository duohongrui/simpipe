#' Simulate scRNA-seq Datasets
#'
#' This is the core function of simulating scRNA-seq datasets. Users can execute
#' this step without parameters estimation step as we will set some default parameters.
#' Otherwise, we provide an alternative choice to complete this step via establishing
#' Docker containers.
#'
#' @param method A character or a string of methods or NULL. It can be \code{all}
#' as all methods are used to estimate paramters from real data. If NULL, the
#' argument \code{parameters} must be generated by [simpipe::estimate_parameters()].
#' @param parameters NULL or the object generated by [simpipe::estimate_parameters()].
#' If NULL, you must input the argument \code{method} above and the default
#' parameters will be used to perform the simulation step.
#' @param ref_data A matrix for one dataset or a list of datasets with their own
#' names. This is usually unused except for some methods, e.g. SCRIP.
#' @param other_prior A list with names of certain parameters. Some methods need
#' extra parameters to execute the estimation step, so you must input them. In
#' simulation step, the number of cells, genes, groups, batches, the percent of
#' DEGs and other variables are usually customed, so before simulating a dataset
#' you must point it out.
#' @param n The time(s) that users want to perform the simulation step with every
#' method.
#' @param seed A random seed. An integer or a vector of integers. If you want to
#' simulate twice or more times by every method you have chosen, it should be a
#' vector. If you do not input this parameter, the default value(s) will be used.
#' @param return_format A character. Alternatives choices: list, SingleCellExperiment,
#' Seurat and h5ad.
#' @param verbose Logical. Whether to return messages or not.
#' @param use_docker Logical. Default is FALSE. Whether to execute the simulation
#' step by establishing a Docker container or not. Suggest that you would better
#' use Docker to execute the step in order to avoid the issues caused by coding
#' environment.
#'
#' @importFrom stringr str_split
#' @importFrom stats setNames
#'
#' @export
#'
simulate_datasets <- function(
  method = NULL,
  parameters = NULL,
  ref_data = NULL,
  other_prior = NULL,
  n = 1,
  seed = simutils::random_seed(),
  return_format = "SingleCellExperiment",
  verbose = TRUE,
  use_docker = FALSE
){

  # Check-----------------------------------------------------------------------
  assertthat::assert_that(is.list(parameters) | is.null(parameters))
  if(is.null(method) & is.null(parameters)){
    stop("You must input information about either method or parameters!")
  }
  if(!is.null(parameters)){
    assertthat::assert_that("simpipe_estimation" %in% class(parameters))
  }
  # Prepare ref_data------------------------------------------------------------
  if(is.matrix(ref_data)){
    ref_data <- list(ref_data = ref_data)
  }
  if(!is.null(ref_data) & is.list(ref_data)){
    if(!is.null(parameters)){
      assertthat::assert_that(length(ref_data) == length(parameters),
                              msg = "The number of reference datasets is not equal to the length of parameters that you have inputted!")
    }
  }
  # Prepare methods-------------------------------------------------------------

  ## All methods
  all_methods <- simmethods::get_method()
  ## If method is NULL
  if(is.null(method) & !is.null(parameters)){
    method <- stringr::str_split(names(parameters),
                                 pattern = "_",
                                 simplify = T)[, 2]
    data_name <- stringr::str_split(names(parameters),
                                    pattern = "_",
                                    simplify = T)[, 1]
  }
  ## If method is not NULL
  if(!is.null(method) & is.null(parameters)){
    ### If method is all
    if(method[1] == "all"){
      method <- names(all_methods)
    }
  }
  ## Assert that method names are right
  assertthat::assert_that(all(method %in% names(all_methods)))
  ### Method
  every_exec_method <- rep(method, each = n)
  every_data_name <- rep(data_name, each = n)
  ### Users set seed or not
  if(length(seed) != n){
    cat("The length of seeds is not identical to the time(s) that every method will be executed \n")
    seed <- seq_len(n)*100
    seed_chara <- paste(as.character(seed), collapse = " ")
    cat(paste0("The seed will be set as: ", seed_chara, " when performing every method\n"))
  }
  seed <- rep(seed, length(method))

  # Prepare parameters and ref_data---------------------------------------------
  parameters <- rep(parameters, each = n)
  if(!is.null(ref_data) & is.list(ref_data)){
    ref_data <- rep(ref_data, each = n)
  }
  # Run methods with each estimation and each method----------------------------
  result <- purrr::map(
    .x = seq_len(length(every_exec_method)),
    .f = function(id) {
      if(verbose){
        cat(paste0("Simulating dataset ", id, "\n"))
      }
      # Users have performed the estimation step
      if(!is.null(parameters)){
        parameters <- parameters[[id]][["estimate_result"]]
      }
      if(!is.null(other_prior)){
        if(all(data_name %in% names(other_prior))){
          other_prior_exec <- other_prior[[every_data_name[id]]]
        }else{
          other_prior_exec <- other_prior
        }
        other_prior_exec <- simutils::check_prior_info(method = every_exec_method[id],
                                                       step = "simulation",
                                                       other_prior = other_prior_exec)
      }
      if(!is.null(ref_data)){
        ref_data <- ref_data[[id]]
      }else{
        ref_data <- NULL
      }
      # Seed
      seed <- seed[id]
      if(use_docker){
        method_execute_container_simulate(
        parameters = parameters,
        method = every_exec_method[id],
        ref_data = ref_data,
        other_prior = other_prior_exec,
        return_format = return_format,
        seed = seed,
        verbose = verbose)
      }else{
        method_execute_function_simulate(
          parameters = parameters,
          method = every_exec_method[id],
          ref_data = ref_data,
          other_prior = other_prior_exec,
          return_format = return_format,
          seed = seed,
          verbose = verbose
        )
      }
    }
  )
  # Prepare list names----------------------------------------------------------
  if(is.null(parameters)){
    list_names <- paste0(every_exec_method, "_", rep(seq_len(n), length(method)))
  }else{
    list_names <- paste0(names(parameters), "_", rep(seq_len(n), length(method)))
  }
  result <- stats::setNames(result, list_names)
  return(result)
}

# result <- simulate_datasets(method = NULL,
#                             parameters = estimate_output,
#                             seed = 10,
#                             ref_data = ref_data,
#                             other_prior = list(mode = "GP-trendedBCV"),
#                             return_format = "h5ad",
#                             verbose = T,
#                             use_docker = TRUE)
#
# result2 <- simulate_datasets(method = NULL,
#                              parameters = estimate_output,
#                              seed = 10,
#                              return_format = "SingleCellExperiment",
#                              verbose = T,
#                              use_docker = TRUE)
#
# result3 <- simulate_datasets(method = NULL,
#                              parameters = estimate_output,
#                              seed = 10,
#                              return_format = "list",
#                              verbose = T,
#                              use_docker = TRUE)
#
# result4 <- simulate_datasets(method = NULL,
#                              parameters = estimate_output,
#                              seed = 10,
#                              ref_data = ref_data,
#                              return_format = "Seurat",
#                              verbose = T,
#                              other_prior = list(mode = "GP-trendedBCV"),
#                              use_docker = TRUE)
#
# result5 <- simulate_datasets(method = "Splat",
#                              parameters = NULL,
#                              seed = 10,
#                              return_format = "Seurat",
#                              verbose = T,
#                              use_docker = TRUE)
#
# result6 <- simulate_datasets(method = NULL,
#                              parameters = estimate_output,
#                              seed = 10,
#                              return_format = "Seurat",
#                              verbose = T,
#                              use_docker = TRUE,
#                              other_prior = list(batchCells = c(1000,1000),
#                                                 group.prob = c(0.5, 0.5),
#                                                 nGenes = 1000))
#
# result7 <- simulate_datasets(method = NULL,
#                              parameters = estimate_output,
#                              seed = 10,
#                              return_format = "SingleCellExperiment",
#                              verbose = T,
#                              use_docker = TRUE,
#                              other_prior = NULL)
#
# result8 <- simulate_datasets(method = "SplatPop",
#                              parameters = NULL,
#                              return_format = "Seurat",
#                              n = 5,
#                              verbose = T,
#                              seed = 111,
#                              use_docker = FALSE)
#
# result9 <- simulate_datasets(method = NULL,
#                              ref_data = NULL,
#                              parameters = estimate_output,
#                              seed = 10,
#                              return_format = "list",
#                              n = 2,
#                              verbose = T,
#                              use_docker = FALSE,
#                              other_prior = list(a = list("group.condition" = sample(c(1,2), 320, replace = T)),
#                                                 b = list("group.condition" = sample(c(1,2), 320, replace = T))))

